---
id: react-scroll-animations
title: React Scroll Animations
description: æˆ‘å€‘å¯ä»¥é€é `IntersectionObserver` ä¾†åµæ¸¬å…ƒç´ æ˜¯å¦åœ¨è¦–çª—ä¸­ï¼Œä¸¦ä¸”é€é CSS transition ä¾†å¯¦ç¾æ»¾å‹•æ™‚çš„å‹•ç•«æ•ˆæœã€‚é€™å€‹æ–¹æ³•ä¸éœ€è¦ä»»ä½•ç¬¬ä¸‰æ–¹å¥—ä»¶ï¼Œè€Œä¸”å¯ä»¥è£½ä½œæˆä¸€å€‹é€šç”¨çš„å‹•ç•«å…ƒä»¶ï¼Œè®“é–‹ç™¼è€…å¯ä»¥è‡ªè¡Œæ±ºå®šå‹•ç•«çš„æ•ˆæœã€‚
sidebar_label: ğŸŸ© React Scroll Animations
hide_title: true
hide_table_of_contents: false
tags: [react, css, animations]
draft: false
last_updated: 2022-09-24
---

<profile
  title="Simple React Scroll Animations With Zero Dependencies"
  url="https://betterprogramming.pub/simple-react-scroll-animations-with-zero-dependencies-b496c1e1c7bd"
  author="Bret Cameron"
  level="beginner"
  category={["react/next", "html/css"]}
/>

æˆ‘å€‘å¯ä»¥é€é `IntersectionObserver` ä¾†åµæ¸¬å…ƒç´ æ˜¯å¦åœ¨è¦–çª—ä¸­ï¼Œä¸¦ä¸”é€é CSS transition ä¾†å¯¦ç¾æ»¾å‹•æ™‚çš„å‹•ç•«æ•ˆæœã€‚é€™å€‹æ–¹æ³•ä¸éœ€è¦ä»»ä½•ç¬¬ä¸‰æ–¹å¥—ä»¶ï¼Œè€Œä¸”å¯ä»¥è£½ä½œæˆä¸€å€‹é€šç”¨çš„å‹•ç•«å…ƒä»¶ï¼Œè®“é–‹ç™¼è€…å¯ä»¥è‡ªè¡Œæ±ºå®šå‹•ç•«çš„æ•ˆæœã€‚

<fig
  src="/img/reading/react-next/2022-09-24-react-scroll-animations/scroll-demo.gif"
  caption="Scroll Demo"
/>

## Step 1. Create a custom hook `useElementOnScreen`

é¦–å…ˆï¼Œæˆ‘å€‘å…ˆå»ºç«‹ä¸€å€‹è‡ªè¨‚çš„ hook `useElementOnScreen` ä¾†åµæ¸¬å…ƒç´ æ˜¯å¦åœ¨è¦–çª—ä¸­ã€‚è£¡é¢çš„ `rootMargin` åƒæ•¸å¯ä»¥è®“æˆ‘å€‘è¨­å®šä¸€å€‹åç§»é‡ï¼Œè®“å‹•ç•«åœ¨è¦–çª—é‚Šç·£çš„æŸå€‹è·é›¢é–‹å§‹ï¼Œè€Œ `0px` å‰‡æ˜¯æ­£å¥½åœ¨é‚Šç·£ã€‚

```tsx
function useElementOnScreen(ref: RefObject<Element>, rootMargin = "0px") {
  const [isIntersecting, setIsIntersecting] = useState(true);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        setIsIntersecting(entry.isIntersecting);
      },
      { rootMargin }
    );
    if (ref.current) {
      observer.observe(ref.current);
    }
    return () => {
      if (ref.current) {
        observer.unobserve(ref.current);
      }
    };
  }, []);
  return isIntersecting;
}
```

## Step 2. Wrap the hook and animation into a container component

ç¬¬äºŒæ­¥ï¼Œæˆ‘å€‘å°‡ `useElementOnScreen` hook å’Œ CSS transition æ•´åˆåˆ°ä¸€å€‹ container component ä¸­ã€‚ `useElementOnScreen` hook æœƒå›å‚³ä¸€å€‹ `boolean` å€¼ï¼Œæˆ‘å€‘å¯ä»¥åˆ©ç”¨é€™å€‹å€¼ä¾†æ±ºå®šå…ƒç´ çš„ `opacity` å’Œ `translate` æ•ˆæœã€‚ `opacity` æœƒåœ¨å…ƒç´ é€²å…¥è¦–çª—æ™‚è®Šç‚º `1`ï¼Œè€Œ `translate` å‰‡æ˜¯åœ¨å…ƒç´ é€²å…¥è¦–çª—æ™‚æœƒå¾ `0 2rem` è®Šç‚º `none`ï¼Œä¹Ÿå°±æ˜¯æ²’æœ‰ä½ç§»ã€‚

```tsx
const AnimateIn: FC<PropsWithChildren> = ({ children }) => {
  const ref = useRef<HTMLDivElement>(null);
  const onScreen = useElementOnScreen(ref);

  return (
    <div
      ref={ref}
      style={{
        opacity: onScreen ? 1 : 0,
        translate: onScreen ? "none" : "0 2rem",
        transition: "600ms ease-in-out",
      }}
    >
      {children}
    </div>
  );
};
```

è¦ä½¿ç”¨é€™å€‹ containerï¼Œæˆ‘å€‘åªéœ€è¦å°‡æˆ‘å€‘çš„å…ƒä»¶åŒ…åœ¨ children å³å¯ã€‚ åˆ°é€™é‚Šï¼Œæˆ‘å€‘å·²ç¶“å»ºç«‹äº†ä¸€å€‹å¯ä»¥åšæ·¡å…¥å‹•ç•«çš„å…ƒä»¶ï¼Œè€Œä¸”ä¸éœ€è¦ä»»ä½•ç¬¬ä¸‰æ–¹å¥—ä»¶ã€‚

```tsx
<AnimateIn>
  <h1>Hello World</h1>
</AnimateIn>
```

## Bonus: Generic Animated Container

æˆ‘å€‘å¯ä»¥é€²ä¸€æ­¥å°‡ `<AnimatedIn>` å…ƒä»¶è®Šå¾—æ›´é€šç”¨ï¼Œé€éå‚³å…¥ `CSSProperties` ä¾†æ±ºå®šå…ƒä»¶çš„ `from` å’Œ `to` ç‹€æ…‹ï¼Œè®“é–‹ç™¼è€…å¯ä»¥è‡ªè¡Œæ±ºå®šå‹•ç•«çš„æ•ˆæœã€‚

```tsx
const AnimateIn: FC<
  PropsWithChildren<{ from: CSSProperties; to: CSSProperties }>
> = ({ from, to, children }) => {
  const ref = useRef<HTMLDivElement>(null);
  const onScreen = useElementOnScreen(ref);
  const defaultStyles: CSSProperties = {
    transition: "600ms ease-in-out",
  };
  return (
    <div
      ref={ref}
      style={
        onScreen
          ? {
              ...defaultStyles,
              ...to,
            }
          : {
              ...defaultStyles,
              ...from,
            }
      }
    >
      {children}
    </div>
  );
};
```

ç¾åœ¨æˆ‘å€‘å¯ä»¥å‚³å…¥ä¸åŒçš„ `from` å’Œ `to` **CSSProperties** ä¾†ç”¢ç”Ÿä¸åŒçš„å‹•ç•«å…ƒä»¶ã€‚

```tsx
const FadeIn: FC<PropsWithChildren> = ({ children }) => (
  <AnimateIn from={{ opacity: 0 }} to={{ opacity: 1 }}>
    {children}
  </AnimateIn>
);

const FadeUp: FC<PropsWithChildren> = ({ children }) => (
  <AnimateIn
    from={{ opacity: 0, translate: "0 2rem" }}
    to={{ opacity: 1, translate: "none" }}
  >
    {children}
  </AnimateIn>
);

const ScaleIn: FC<PropsWithChildren> = ({ children }) => (
  <AnimateIn from={{ scale: "0" }} to={{ scale: "1" }}>
    {children}
  </AnimateIn>
);

export const Animate = {
  FadeIn,
  FadeUp,
  ScaleIn,
};

<Animate.ScaleIn>
  <h1>Hello World</h1>
</Animate.ScaleIn>;
```
